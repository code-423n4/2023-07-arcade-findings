## Arcade Project: QA Report


### [Low-01] Truncation when casting `withdrawable` to `uint128(withdrawable)`

The `ARCDVestingVault#claim` performs unsafe type casting of `withdrawable` amount from type uint256 to uint128. If the  `withdrawable` amount is greater than type(uint128).max, it would silently overflow and modify `ARCDVestingVaultStorage` grant storage slot with wronged withdrawn value.  

```solidity
    function claim(uint256 amount) external override nonReentrant {
        ...SNIP...

        // get the withdrawable amount
        uint256 withdrawable = _getWithdrawableAmount(grant);
        if (amount > withdrawable) revert AVV_InsufficientBalance(withdrawable);

        // update the grant's withdrawn amount
        if (amount == withdrawable) {
            grant.withdrawn += uint128(withdrawable); //  <= Unsafe downcasting
        } else {
            grant.withdrawn += uint128(amount); // <= Unsafe downcasting
            withdrawable = amount;
        }

        ...SNIP...
    }

```

It is recommended to use OpenZeppelin SafeCast library to avoid such integer truncations,

### [Non Critical-02] Repetitive approval methods should be avoided

In `ArcadeTreasury.sol` implementation, multiple approval methods uses the repetitive code pattern which is not the best practices. 

```solidity
    function approveSmallSpend(
        address token,
        address spender,
        uint256 amount
    ) external onlyRole(CORE_VOTING_ROLE) nonReentrant {
        if (spender == address(0)) revert T_ZeroAddress("spender");
        if (amount == 0) revert T_ZeroAmount();

        _approve(token, spender, amount, spendThresholds[token].small);
    }

    function approveMediumSpend(
        address token,
        address spender,
        uint256 amount
    ) external onlyRole(CORE_VOTING_ROLE) nonReentrant {
        if (spender == address(0)) revert T_ZeroAddress("spender");
        if (amount == 0) revert T_ZeroAmount();

        _approve(token, spender, amount, spendThresholds[token].medium);
    }

    function approveLargeSpend(
        address token,
        address spender,
        uint256 amount
    ) external onlyRole(CORE_VOTING_ROLE) nonReentrant {
        if (spender == address(0)) revert T_ZeroAddress("spender");
        if (amount == 0) revert T_ZeroAmount();

        _approve(token, spender, amount, spendThresholds[token].large);
    }
```

It is recommeded make a single approval function that take one extra input parameter `uint8 spendType`, perform the action to the corresponding spendType, if 0 -> small, 1 -> medium, 2 -> large

